<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Servlet实例化异常解决办法</title>
    <url>/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><blockquote>
<p>系统环境：IDEA 2021.2，Tomcat 10</p>
</blockquote>
<p>  在IDEA中配置好Servlet文件路径，项目结构如下：<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-10-12.png"></p>
<p>Tomcat配置如下：<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-11-18.png"></p>
<p>以ch07_8_tijiao.jsp为例，运行后第一个界面显示正常<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-22-36.png"></p>
<p>但当输入2个数据并点击提交后，servlet出现实例化异常<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-24-22.png"></p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>项目结构’web-lib’中导入Tomcat的Tomcat-api.jar包以及servlet-api.jar包，并导入进项目库中</p>
<div align="center">

<p><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-28-44.png"></p>
</div>

<p>如果Tomcat版本为10.0以下时，做完上面步骤问题消失，可以正常运行，<br>但当Tomcat版本为10.0时，仍然会显示实例化异常，<br>根本原因是Tomcat 10的servlet-api中并非旧版本的javax.servlet，而是jakarta.servlet，<br>此时需要将项目src目录下的java源文件中import javax.servlet全部改为jakarta.servlet，保存后即可正常运行</p>
<blockquote>
<p>源代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改后：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-27-19-25-20.png"><br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-50-35.png"><br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-50-59.png"></p>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>代价函数</title>
    <url>/2022/10/11/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/ApplicationFrameHost_Gvqy4wLebk.png"></p>
<blockquote>
<p>代价函数（Cost Function）在机器学习中的每一种算法中都很重要，因为训练模型的过程就是优化代价函数的过程，代价函数对每个参数的偏导数就是梯度下降中提到的梯度，防止过拟合时添加的正则化项也是加在代价函数后面的</p>
</blockquote>
<div>
<h1><font color="CadetBlue">1.什么是代价函数</font>
</h1>
</div>

<p>        概况来讲，任何能够衡量模型预测出来的值h(θ)与真实值y之间的差异的函数都可以叫做代价函数J(θ)。</p>
<p>        代价函数就是用于找到最优解的目的函数，这也是代价函数的作用。</p>
<p>　　<strong><mark>损失函数（Loss Function ）</mark></strong> 是定义在单个样本上的，算的是一个样本的误差。</p>
<p>　　<strong><mark>代价函数（Cost Function ）</mark></strong> 是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。</p>
<p>　　<strong><mark>目标函数（Object Function）</mark></strong> 定义为：最终需要优化的函数。等于经验风险+结构风险（也就是Cost Function + 正则化项）。</p>
<div>
<h1><font color="CadetBlue">2.代价函数的作用是什么</font>
</h1>
</div>

<p>        假设，给定一个关于 <code>x</code>  和 <code>y</code>  的数据集，该数据集可以被认定为一个线性回归模型，设定假象函数 : <font color="DeepSkyBlue">f<sub>w,b</sub></font> (x) &#x3D; <font color="DeepSkyBlue">w</font>x + <font color="DeepSkyBlue">b</font> </p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_bS2PBfg7tJ.png" title alt data-align="center">

<p>        当函数中 <code>w</code>  和 <code>b</code>  两个参数发生改变时，函数也会偏离或者靠近数据集，为了使假象函数跟接近于真实的目标函数或更能使其正确的表示这个数据集，此时就可以引入代价函数</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_PNGYjBNfTI.png" title alt data-align="center">

<p>        以平方误差代价函数为例，从最简单的单一参数来看，假设函数为：J<sub>w</sub> &#x3D; wx，平方误差代价函数的主要思想就是将实际数据给出的值与我们拟合出的线的对应值做差，求出我们拟合出的直线与实际的差距。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_QKEXlhGUBk.png" title alt data-align="center">

<p>        为了使这个值不受个别极端数据影响而产生巨大波动，采用类似方差再取二分之一的方式来减小个别数据的影响。这样，就产生了代价函数：</p>
<img title src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_dfDTIpbfSv.png" alt width="394" data-align="center">

<p>将其扩充成2个参数，就变成了<img title src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_DkMygOkPLc.png" alt width="247" data-align="inline"></p>
]]></content>
      <categories>
        <category>机器深度学习Deeplearning.AI</category>
      </categories>
      <tags>
        <tag>AI理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>初始Metasploit</title>
    <url>/2023/04/02/%E5%88%9D%E5%A7%8BMetasploit-1/</url>
    <content><![CDATA[<p>环境：</p>
<p>攻击机：Kali Linux</p>
<p>受害机：Windows 7</p>
<h1 id="什么是-Metasploit"><a href="#什么是-Metasploit" class="headerlink" title="什么是 Metasploit"></a>什么是 Metasploit</h1><p>    这是一个免费的、开源的渗透测试框架，由 H.D.Moore 在 2003 年发布，后来被 Rapid7 收购。Metasploit 核心中绝大部分有 Rudy 实现，一小部分由汇编和C语言实现。</p>
<h1 id="为什么要用-Metasploit"><a href="#为什么要用-Metasploit" class="headerlink" title="为什么要用 Metasploit"></a>为什么要用 Metasploit</h1><ol>
<li><p>效率：Metasploit 提供了一系列已经开发好的攻击模块，使得攻击者能够快速地在目标系统上执行攻击，同时减少了犯错的机会。</p>
</li>
<li><p>易用性：Metasploit 使用简单，用户无需具备深入的技术知识，只需了解一些基本的操作就能使用它进行渗透测试。</p>
</li>
<li><p>支持多种操作系统：Metasploit 支持多种操作系统，包括 Windows、Linux、macOS等，因此，它可以用于攻击各种不同的目标系统。</p>
</li>
<li><p>兼容性：Metasploit 兼容多种漏洞扫描工具和其他渗透测试工具，使得用户可以将其集成到他们的工具链中。</p>
</li>
<li><p>实用性：Metasploit 具有强大的漏洞利用功能，可以进行端口扫描、漏洞扫描、漏洞利用等，从而帮助用户发现和利用系统中的漏洞。</p>
</li>
</ol>
<h1 id="如何使用-Metasploit"><a href="#如何使用-Metasploit" class="headerlink" title="如何使用 Metasploit"></a>如何使用 Metasploit</h1><h2 id="Metasploit的模块"><a href="#Metasploit的模块" class="headerlink" title="Metasploit的模块"></a>Metasploit的模块</h2><ol>
<li><p>扫描模块（Scanning modules）：用于发现目标系统的开放端口和漏洞，常见的扫描模块包括nmap、arp_scanner、ping_sweep等。</p>
</li>
<li><p>渗透模块（Exploit modules）：用于利用目标系统的漏洞进行攻击，以获取系统权限或者执行命令，常见的渗透模块包括MS08_067_netapi、MS17_010_eternalblue等。</p>
</li>
<li><p>模块辅助（Auxiliary modules）：提供一些辅助功能，如指纹识别、密码破解、后门创建等，常见的辅助模块包括enum、ftp_login、smb_login等。</p>
</li>
<li><p>转发模块（Payload modules）：用于在攻击成功后提供一个交互式的shell，以执行更复杂的攻击，常见的转发模块包括meterpreter_reverse_tcp、meterpreter_reverse_http等。</p>
</li>
<li><p>木马模块（Shellcode modules）：用于创建一些自定义的木马程序，可以绕过一些安全措施，常见的木马模块包括windows&#x2F;meterpreter&#x2F;reverse_https、windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp等</p>
</li>
</ol>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>    扫描模块是Metasploit中的一类模块，用于发现目标系统的开放端口和漏洞。以下是一些常见的扫描模块及其功能：</p>
<ol>
<li><p>Nmap扫描模块：Nmap是一个开源的端口扫描工具，Metasploit中的nmap模块可以调用Nmap的功能，扫描目标系统的开放端口，以及判断操作系统、服务和应用程序版本等信息。</p>
</li>
<li><p>Ping扫描模块：ping_sweep模块可以通过发送ICMP包来扫描目标系统是否在线，快速确定目标的IP地址是否可用。</p>
</li>
<li><p>ARP扫描模块：arp_scanner模块可以通过发送ARP包来扫描目标局域网上的主机，快速获取局域网内的主机IP和MAC地址。</p>
</li>
<li><p>SMB扫描模块：smb_version模块可以利用SMB协议获取目标系统上共享文件夹的信息，包括共享文件夹名称、操作系统版本等。</p>
</li>
<li><p>Web应用程序扫描模块：Metasploit中的web_app_scanner模块可以扫描目标Web应用程序的漏洞，包括SQL注入、XSS漏洞等。</p>
</li>
</ol>
<h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><p>    以 Nmap 为例，查看受害机的 IP，攻击机测试连通性，结果可以 PING 通，进行下一步</p>
<p>    <img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021415267.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021419931.png"></p>
<p>    使用nmap [ 受害机 IP ] 查看受害机开放的端口以及对应的服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021421460.png"></p>
<h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>    Metasploit渗透模块是用于利用已知漏洞或弱点对目标系统进行攻击的工具。以下是几个常用的渗透模块及其功能：</p>
<ol>
<li><p>exploit：用于执行针对已知漏洞的攻击，例如远程代码执行、缓冲区溢出、文件包含等。使用这个模块可以获取对目标系统的完全控制。</p>
</li>
<li><p>payload：用于在目标系统上执行特定的操作，例如打开反向shell、上传&#x2F;下载文件、添加管理员账户等。这个模块的功能取决于攻击者的目的和实际需求。</p>
</li>
<li><p>auxiliary：用于执行非攻击性任务的模块，例如端口扫描、漏洞扫描、密码爆破、信息收集等。这个模块通常用于获取目标系统的信息，以便为后续攻击做准备。</p>
</li>
<li><p>post：用于在攻击成功后对目标系统进行后续操作的模块，例如上传后门、获取系统信息、清除痕迹等。这个模块通常用于长期攻击和渗透，以保持对目标系统的持续访问。</p>
</li>
</ol>
<h4 id="Example：-1"><a href="#Example：-1" class="headerlink" title="Example："></a>Example：</h4><p>    以永恒之蓝为例，搜索永恒之蓝漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021501597.png"></p>
<p>    使用探测模块 auxiliary ，show options 命令查看所需的参数，默认必填参数中只有RHOSTS 没有补充，RHOSTS 为被攻击的主机IP，RPORT 为端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021503166.png"></p>
<p>    配置RHOSTS，使用set RHOSTS [ IP ]</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021506629.png"></p>
<p>    run指令进行探测，[+] 为探测到的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021507879.png"></p>
<p>    接下来可以使用 exploit 模块进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510647.png"> <img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510939.png"></p>
<p>    RHOSTS 为被攻击机的 IP，LHOST , LPORT 为监听主机的 IP 和端口号，设置完成后使用RUN 指令进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021512392.png"></p>
<h4 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h4><p>    运行了完命令之后，我们开启了一个 reverse TCP 监听器来监听本地的 4444 端口，即我（攻击者）的本地主机地址（LHOST）和端口号（LPORT）。运行成功之后，我们将会看到命令提示符 meterpreter &gt; 出现，我们输入： shell  即可切换到目标主机的windows shell，要想从目标主机 shell 退出到 meterpreter ，我们只需输入：exit 。也可以使用其他指令进行更多操作。（ 例如使用 upload 指令上传文件到被攻击机 ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021515274.png"></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降</title>
    <url>/2022/10/11/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>机器深度学习Deeplearning.AI</category>
      </categories>
  </entry>
  <entry>
    <title>初识SQL注入--小结</title>
    <url>/2023/04/02/%E5%88%9D%E8%AF%86SQL%E6%B3%A8%E5%85%A5-%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h1><p>sql注入是指web应用程序对用户输入数据的合法性没有进行判断或者过滤不严，导致攻击者可以构造恶意语句，获取数据库中的数据，在一定条件下甚至可以拿到shell</p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>mysql5.0以上存在一个自带的数据库名为 <strong>information__schema</strong> ,是一个存储纪录了所有数据库名、表名、列名的数据库，也相当于可以从这里查询指定数据库下面的表名和列名的信息，这是因为在数据库中”.”表示下一级。例如：books.book 表示 books 数据库下面的book 表名</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">information_schema.schemata：纪录所有数据库的表</span><br><span class="line">information_schema.<span class="keyword">tables</span>：纪录所有表名的表</span><br><span class="line">information_schema.<span class="keyword">columns</span>；纪录所有列名的表</span><br><span class="line">相当于变量：</span><br><span class="line"><span class="built_in">table_name</span>:表名</span><br><span class="line"><span class="built_in">column_name</span>:列名</span><br><span class="line">table_schema:数据库名</span><br></pre></td></tr></table></figure>

<h1 id="Step-1-判断"><a href="#Step-1-判断" class="headerlink" title="Step 1. 判断"></a>Step 1. 判断</h1><h2 id="判断是否有注入点"><a href="#判断是否有注入点" class="headerlink" title="判断是否有注入点"></a>判断是否有注入点</h2><p>首先需要判断注入点是否存在，如果在页面的url中存在某些参数，比如下面这个URL中就存在一个id参数：<a href="http://xxxxx.xxx/?id=1">http://xxxxx.xxx/?id=1</a></p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101355731.png" title alt data-align="center">

<p>就可以尝试改变id的数值，将参数值+1或-1，然后查看页面展示的内容是否会变化，如果页面会发生变化，则我们就可以初步判断，这个id会带入数据库查询，查询后的内容会显示到页面中来。</p>
<p>猜测查询的SQL语句大致为：</p>
<p><code>select * from [表名] where id = 1;</code></p>
<h2 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h2><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>在id后面跟一个单引号进行尝试，发现报错信息为 <code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code> ，去掉报错信息本身的左右单引号，为 <code>&#39;1&#39;&#39; LIMIT 0,1</code> ，发现1的左方1个单引号，右方2个单引号。可以判断出SQL语句为<code>select * from [表名] where id = ’1‘  LIMIT 0,1;</code> </p>
<p>报错信息分析：因为我们在id后多跟了一个单引号，导致查询语句在id后闭合，后续内容无法正常执行，所以出现这个报错</p>
<p>由此判断id的接受类型为字符型</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101358449.png" title alt data-align="center">

<h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>判断是否为数字型依然选择添加单引号测试，发现报错结果为 <code>&#39;&#39; LIMIT 0,1&#39;</code> ，去除报错信息本身的左右单引号，为 <code>&#39; LIMIT 0,1</code> ，说明跟在id后的单引号多余，导致查询语句无法执行</p>
<p>报错信息分析：传入的参数前面并没有引号包裹，多出的单引号导致语句异常</p>
<p>由此判断id的接受类型为数字型</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101410758.png" title alt data-align="center">

<h3 id="添加单引号"><a href="#添加单引号" class="headerlink" title="添加单引号"></a>添加单引号</h3><p>添加了单引号之后，如果页面中直接进行了报错，并且报错的信息显示到了页面中来，说明我们输入的单引号被带入了数据库查询，我们就可以直接判断此处存在sql注入漏洞。并且结合之前判断的页面是否有回显，就可以尝试进行联合查询注入或是报错注入。</p>
<h3 id="添加逻辑运算"><a href="#添加逻辑运算" class="headerlink" title="添加逻辑运算"></a>添加逻辑运算</h3><p>添加 <code>and 1 = 1</code> 和 <code>and 1 = 2</code> </p>
<p>在添加逻辑运算之前我们需要判断或者猜测注入点的数据类型和闭合方式，并对语句进行相应的引号、括号闭合。</p>
<p>比如字符型我们可以直接添加and 1&#x3D;1 ，而单验号闭合的字符型我们就需要添加 <code>&#39;and &#39;1&#39;=1</code> ，或 <code>&#39;and &#39;1&#39;=1&#39; #</code> 使用注释符号将后面的引号直接注释掉。</p>
<p>添加了逻辑运算符之后提交，因为 1&#x3D;1 恒为真，而 1&#x3D;2 恒为假，所以如果我们的输入带入了数据库，一定会影响到 SQL 语句的布尔状态，如果两次查询返回的页面不同，说明页面存在布尔状态，此处存在注入漏洞，可以考虑使用布尔盲注进行注入。</p>
<h3 id="添加sleep-函数"><a href="#添加sleep-函数" class="headerlink" title="添加sleep( )函数"></a>添加sleep( )函数</h3><p><code>sleep()</code> 函数可以让程序在当前位置停留指定的时间，于是我们可以通过观察页面相应的时间来判断我们插入的参数是否会被带入数据库执行。</p>
<p>在参数后添加 <code>and sleep(5)</code> 然后观察页面响应时间是否明显变长，或直接在开发者工具中网络选项卡下观察页面的响应时间。如果页面响应时间确实按照我们的要求增加了5秒，则说明此处存在注入漏洞，我们可以考虑通过延时注入。</p>
<h2 id="执行注入"><a href="#执行注入" class="headerlink" title="执行注入"></a>执行注入</h2><h3 id="SQL注释"><a href="#SQL注释" class="headerlink" title="SQL注释"></a>SQL注释</h3><p>SQL 注入过程中注释符号有以下几种表达方式：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">%<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>SQL注入过程中注释符号的作用是把后面不需要的语句注释掉，以保证SQL命令的完整性。在注入的查询语句后跟注释可以屏蔽掉原本正常查询语句的部分内容。</p>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><blockquote>
<p>有信息回显才能用</p>
</blockquote>
<h4 id="1-爆列"><a href="#1-爆列" class="headerlink" title="1. 爆列"></a>1. 爆列</h4><p>使用 <code>order by</code> 语句测试当前表有多少列， <code>order by</code> 语句的作用是按照某一列进行排序，在 MySQL 数据库中我们可以使用数字来代替对应列的列名，如果数据库中没有对应的列，就会报错。所以我们可以通过依次增加数字，直到报错，然后报错前的数字就是表的列数。例如：</p>
<p>[order by 1]-&gt;[order by 2]-&gt;[order by 3]-&gt;[order by 4]-&gt;数据库报错</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101425795.png" title alt data-align="center">

<h4 id="2-爆数据库"><a href="#2-爆数据库" class="headerlink" title="2. 爆数据库"></a>2. 爆数据库</h4><p>使用 <code>database()</code> 可以获取当前使用的数据库名称</p>
<p>使用联合查询语句进行查询： </p>
<p><code>union select 1,database(),3 #</code> </p>
<p>回显信息可以看到Login name已经被替换为了数据库的名称。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101433026.png" title alt data-align="center">

<h4 id="4-爆表"><a href="#4-爆表" class="headerlink" title="4. 爆表"></a>4. 爆表</h4><p>利用<strong>前提</strong>中的方法，使用联合查询语句： </p>
<p><code>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = database() #</code> </p>
<p>可以查到数据库中的所有表，其中 <code>group_concat()</code> 的意思为将查询到的所有table_name聚合为一条内容，从而解决某些网站只能回显一行的情况。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101441978.png" title alt data-align="center">

<h4 id="5-爆列"><a href="#5-爆列" class="headerlink" title="5. 爆列"></a>5. 爆列</h4><p>对于可能有敏感信息的表可以使用联合查询语句：</p>
<p><code>union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#39;&lt;table&gt;&#39;</code> </p>
<p>可以查到 <code>&lt;table&gt;</code> 表中的所有列。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101447487.png" title alt data-align="center">

<h4 id="6-爆值"><a href="#6-爆值" class="headerlink" title="6. 爆值"></a>6. 爆值</h4><p>现在已经得到了数据库名，表名，列。接下来就是需要获取最重要的值，依然使用联合查询语句：</p>
<p><code>union select 1,group_concat(&lt;column1&gt;,&lt;column2&gt;),3 from &lt;table&gt; #</code> </p>
<p><code>&lt;column1&gt;,&lt;column2&gt;</code> 表示想要获取数据的列。</p>
<p><code>&lt;table&gt;</code> 表示想要获取数据的表。<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101453479.png" title alt data-align="center"></p>
<h4 id="剩余内容正在施工…"><a href="#剩余内容正在施工…" class="headerlink" title="剩余内容正在施工…"></a>剩余内容正在施工…</h4>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
</search>
